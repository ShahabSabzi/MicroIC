# -*- coding: utf-8 -*-
"""Untitled25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EBEQZ-ff8_kkIfs5UlIP6bW6Dy9rYjpt
"""

import numpy as np
import random
import pandas as pd
import plotly.graph_objects as go

# Signal parameters
FS = 1000  # Sampling frequency (Hz)
T_RAMP = 3  # Ramp duration (s)
T_WAIT = 1  # Hold duration (s)
V_MAX = 5  # Max voltage (V)
SPIKE_MAG = -1  # Spike amplitude (V)
SPIKE_DUR_MIN = 0.05  # Min spike duration (s)
SPIKE_DUR_MAX = 0.1  # Max spike duration (s)
TARGET_V = 3  # Voltage for spike placement (V)
NOISE_STD = 0.02  # Standard deviation of background noise (V)
WINDOW_SIZE = 11  # Filter window size for median filter (odd, samples)
KALMAN_Q = 0.001  # Process noise covariance
KALMAN_R = 0.01  # Measurement noise covariance
SPIKE_THRESHOLD = 0.1  # Threshold for spike rejection (V)

def generate_signal(fs, t_ramp, t_wait, v_max, spike_mag, spike_dur_min, spike_dur_max, target_v, noise_std):
    """Generate triangular signal with random spikes and background noise."""
    t_total = 2 * t_ramp + t_wait
    t = np.linspace(0, t_total, int(t_total * fs), endpoint=True)
    ramp_up = np.linspace(0, v_max, int(t_ramp * fs), endpoint=False)
    hold = v_max * np.ones(int(t_wait * fs))
    ramp_down = np.linspace(v_max, 0, int(t_ramp * fs))
    voltage = np.concatenate([ramp_up, hold, ramp_down])
    noise = np.random.normal(0, noise_std, len(voltage))
    voltage += noise
    for ramp_start, direction in [(0, 1), (int((t_ramp + t_wait) * fs), -1)]:
        spike_dur_samples = random.randint(int(spike_dur_min * fs), int(spike_dur_max * fs))
        ramp_slice = slice(ramp_start, ramp_start + int(t_ramp * fs))
        indices = np.where((voltage[ramp_slice] >= target_v - 0.05) &
                           (voltage[ramp_slice] <= target_v + 0.05))[0]
        if len(indices) == 0:
            continue
        target_idx = indices[0 if direction == 1 else -1] + ramp_start
        end_idx = min(target_idx + spike_dur_samples, len(voltage))
        voltage[target_idx:end_idx] += spike_mag
    return t, voltage

def causal_median_filter(data, window_size):
    """Apply causal median filter to signal."""
    if window_size % 2 == 0:
        raise ValueError("Window size must be odd")
    filtered = np.zeros_like(data)
    for i in range(len(data)):
        start = max(0, i - window_size + 1)
        filtered[i] = np.median(data[start:i+1])
    return filtered

def kalman_filter(median_voltage, q, r, spike_threshold, fs):
    """Apply Kalman Filter to median-filtered signal with spike rejection."""
    n = len(median_voltage)
    filtered = np.zeros(n)

    # Kalman Filter setup: state = [voltage, velocity]
    x = np.array([median_voltage[0], 0.0])  # Initial state: voltage, velocity=0
    P = np.eye(2) * 1.0  # Initial covariance
    F = np.array([[1, 1/fs], [0, 1]])  # State transition: v_k = v_{k-1} + \dot{v}*dt
    H = np.array([[1, 0]])  # Measurement model: measure voltage
    Q = np.eye(2) * q  # Process noise covariance
    R = r  # Measurement noise covariance (scalar)
    I = np.eye(2)  # Identity matrix

    filtered[0] = x[0]

    for i in range(1, n):
        # Predict step
        x = F @ x  # Predict state
        P = F @ P @ F.T + Q  # Predict covariance

        # Measurement update
        z = median_voltage[i]
        y = z - (H @ x)[0]  # Measurement residual (scalar)
        if abs(y) > spike_threshold:  # Reject spikes
            filtered[i] = x[0]  # Use predicted voltage
            continue

        S = (H @ P @ H.T)[0,0] + R  # Innovation covariance (scalar)
        K = (P @ H.T) / S  # Kalman gain
        x = x + K[:,0] * y  # Update state
        P = (I - K @ H) @ P  # Update covariance
        filtered[i] = x[0]  # Store filtered voltage (scalar)

    return filtered

def plot_signals(t, signals, names, colors):
    """Create interactive plot for multiple signals."""
    fig = go.Figure()
    for sig, name, color in zip(signals, names, colors):
        fig.add_trace(go.Scatter(
            x=t, y=sig, mode='lines', name=name, line=dict(color=color)
        ))
    fig.update_layout(
        title='Potentiometer Reading with Noise and Kalman Filtering',
        xaxis_title='Time (s)',
        yaxis_title='Voltage (V)',
        yaxis_range=[0, 6],
        showlegend=True,
        hovermode='x unified'
    )
    fig.show()

# Generate the signal with noise
t, voltage = generate_signal(FS, T_RAMP, T_WAIT, V_MAX, SPIKE_MAG, SPIKE_DUR_MIN, SPIKE_DUR_MAX, TARGET_V, NOISE_STD)

# Apply the causal median filter
voltage_med = causal_median_filter(voltage, WINDOW_SIZE)

# Apply the Kalman Filter on median-filtered signal
voltage_kalman = kalman_filter(voltage_med, KALMAN_Q, KALMAN_R, SPIKE_THRESHOLD, FS)

# Save to CSV and Excel
data = pd.DataFrame({
    'Time (s)': t,
    'Original Voltage (V)': voltage,
    'Median Filtered Voltage (V)': voltage_med,
    'Kalman Filtered Voltage (V)': voltage_kalman
})

# Plot results
signals = [voltage, voltage_med, voltage_kalman]
names = ['Original with Noise', 'Median Filtered', 'Kalman Filtered']
colors = ['blue', 'green', 'red']
plot_signals(t, signals, names, colors)

import numpy as np
import random
import pandas as pd
import plotly.graph_objects as go

# Signal parameters
FS = 1000  # Sampling frequency (Hz)
T_RAMP = 3  # Ramp duration (s)
T_WAIT = 1  # Hold duration (s)
V_MAX = 5  # Max voltage (V)
SPIKE_MAG = 1  # Spike amplitude (V)
SPIKE_DUR_MIN = 0.05  # Min spike duration (s)
SPIKE_DUR_MAX = 0.1  # Max spike duration (s)
TARGET_V = 3  # Voltage for spike placement (V)
NOISE_STD = 0.02  # Standard deviation of background noise (V)
AVG_WINDOW_SIZES = [4, 20, 50]  # Window sizes for averaging filters

def generate_signal(fs, t_ramp, t_wait, v_max, spike_mag, spike_dur_min, spike_dur_max, target_v, noise_std):
    """Generate triangular signal with random spikes and background noise."""
    t_total = 2 * t_ramp + t_wait
    t = np.linspace(0, t_total, int(t_total * fs), endpoint=True)
    ramp_up = np.linspace(0, v_max, int(t_ramp * fs), endpoint=False)
    hold = v_max * np.ones(int(t_wait * fs))
    ramp_down = np.linspace(v_max, 0, int(t_ramp * fs))
    voltage = np.concatenate([ramp_up, hold, ramp_down])
    noise = np.random.normal(0, noise_std, len(voltage))
    voltage += noise
    for ramp_start, direction in [(0, 1), (int((t_ramp + t_wait) * fs), -1)]:
        spike_dur_samples = random.randint(int(spike_dur_min * fs), int(spike_dur_max * fs))
        ramp_slice = slice(ramp_start, ramp_start + int(t_ramp * fs))
        indices = np.where((voltage[ramp_slice] >= target_v - 0.05) &
                           (voltage[ramp_slice] <= target_v + 0.05))[0]
        if len(indices) == 0:
            continue
        target_idx = indices[0 if direction == 1 else -1] + ramp_start
        end_idx = min(target_idx + spike_dur_samples, len(voltage))
        voltage[target_idx:end_idx] += spike_mag
    return t, voltage

def causal_averaging_filter(data, window_size):
    """Apply causal averaging filter to signal."""
    filtered = np.zeros_like(data)
    for i in range(len(data)):
        start = max(0, i - window_size + 1)
        filtered[i] = np.mean(data[start:i+1])
    return filtered

def plot_signals(t, signals, names, colors):
    """Create interactive plot for multiple signals."""
    fig = go.Figure()
    for sig, name, color in zip(signals, names, colors):
        fig.add_trace(go.Scatter(
            x=t, y=sig, mode='lines', name=name, line=dict(color=color)
        ))
    fig.update_layout(
        title='Potentiometer Reading with Noise and Averaging Filters',
        xaxis_title='Time (s)',
        yaxis_title='Voltage (V)',
        yaxis_range=[0, 6],
        showlegend=True,
        hovermode='x unified'
    )
    fig.show()

# Generate the signal with noise
t, voltage = generate_signal(FS, T_RAMP, T_WAIT, V_MAX, SPIKE_MAG, SPIKE_DUR_MIN, SPIKE_DUR_MAX, TARGET_V, NOISE_STD)

# Apply averaging filters with different window sizes
voltage_avg = {w: causal_averaging_filter(voltage, w) for w in AVG_WINDOW_SIZES}

# Save to CSV
data = pd.DataFrame({
    'Time (s)': t,
    'Original Voltage (V)': voltage,
    **{f'Avg Filtered Voltage (Window={w}) (V)': voltage_avg[w] for w in AVG_WINDOW_SIZES}
})
data.to_csv('signal_data.csv', index=False)

# Plot results
signals = [voltage] + [voltage_avg[w] for w in AVG_WINDOW_SIZES]
names = ['Original with Noise'] + [f'Avg Filter (Window={w})' for w in AVG_WINDOW_SIZES]
colors = ['blue', 'orange', 'purple', 'brown']
plot_signals(t, signals, names, colors)

import numpy as np
import random
import pandas as pd
import plotly.graph_objects as go

# Signal parameters
FS = 1000  # Sampling frequency (Hz)
T_RAMP = 3  # Ramp duration (s)
T_WAIT = 1  # Hold duration (s)
V_MAX = 5  # Max voltage (V)
SPIKE_MAG = 1  # Spike amplitude (V)
SPIKE_DUR_MIN = 0.001  # Min spike duration (s)
SPIKE_DUR_MAX = 0.01  # Max spike duration (s)
TARGET_V = 3  # Voltage for spike placement (V)
NOISE_STD = 0.02  # Standard deviation of background noise (V)
MEDIAN_WINDOW_SIZE = 11  # Window size for median filter (odd, samples)

def generate_signal(fs, t_ramp, t_wait, v_max, spike_mag, spike_dur_min, spike_dur_max, target_v, noise_std):
    """Generate triangular signal with random spikes and background noise."""
    t_total = 2 * t_ramp + t_wait
    t = np.linspace(0, t_total, int(t_total * fs), endpoint=True)
    ramp_up = np.linspace(0, v_max, int(t_ramp * fs), endpoint=False)
    hold = v_max * np.ones(int(t_wait * fs))
    ramp_down = np.linspace(v_max, 0, int(t_ramp * fs))
    voltage = np.concatenate([ramp_up, hold, ramp_down])
    noise = np.random.normal(0, noise_std, len(voltage))
    voltage += noise
    for ramp_start, direction in [(0, 1), (int((t_ramp + t_wait) * fs), -1)]:
        spike_dur_samples = random.randint(int(spike_dur_min * fs), int(spike_dur_max * fs))
        ramp_slice = slice(ramp_start, ramp_start + int(t_ramp * fs))
        indices = np.where((voltage[ramp_slice] >= target_v - 0.05) &
                           (voltage[ramp_slice] <= target_v + 0.05))[0]
        if len(indices) == 0:
            continue
        target_idx = indices[0 if direction == 1 else -1] + ramp_start
        end_idx = min(target_idx + spike_dur_samples, len(voltage))
        voltage[target_idx:end_idx] += spike_mag
    return t, voltage

def causal_median_filter(data, window_size):
    """Apply causal median filter to signal."""
    if window_size % 2 == 0:
        raise ValueError("Window size must be odd")
    filtered = np.zeros_like(data)
    for i in range(len(data)):
        start = max(0, i - window_size + 1)
        filtered[i] = np.median(data[start:i+1])
    return filtered

def plot_signals(t, signals, names, colors):
    """Create interactive plot for multiple signals."""
    fig = go.Figure()
    for sig, name, color in zip(signals, names, colors):
        fig.add_trace(go.Scatter(
            x=t, y=sig, mode='lines', name=name, line=dict(color=color)
        ))
    fig.update_layout(
        title='Potentiometer Reading with Noise and Median Filter',
        xaxis_title='Time (s)',
        yaxis_title='Voltage (V)',
        yaxis_range=[0, 6],
        showlegend=True,
        hovermode='x unified'
    )
    fig.show()

# Generate the signal with noise
t, voltage = generate_signal(FS, T_RAMP, T_WAIT, V_MAX, SPIKE_MAG, SPIKE_DUR_MIN, SPIKE_DUR_MAX, TARGET_V, NOISE_STD)

# Apply the causal median filter
voltage_med = causal_median_filter(voltage, MEDIAN_WINDOW_SIZE)

# Save to CSV
data = pd.DataFrame({
    'Time (s)': t,
    'Original Voltage (V)': voltage,
    'Median Filtered Voltage (V)': voltage_med
})
data.to_csv('signal_data.csv', index=False)

# Plot results
signals = [voltage, voltage_med]
names = ['Original with Noise', 'Median Filter (Window=11)']
colors = ['blue', 'green']
plot_signals(t, signals, names, colors)

from graphviz import Digraph

# Create a new directed graph
dot = Digraph(comment='Kalman Filter on Median-Filtered Signal for Door-Zone Module ECU')
dot.attr(rankdir='TB', size='8,12')  # Top-to-bottom layout, size in inches

# Define node styles
dot.attr('node', shape='ellipse', style='filled', fillcolor='lightblue')
dot.node('start', 'Start\nRaw Potentiometer Signal\n(1000 Hz, 1 V spikes, 50-100 ms, 0.02 V noise)')

dot.attr('node', shape='box', style='filled', fillcolor='lightgreen')
dot.node('median', 'Median Causal Filter\nWindow = 11 samples (11 ms)\nSort current + 10 previous samples\nOutput: Median voltage')

dot.node('init_kalman', 'Initialize Kalman Filter\nState: x = [v_0, 0]^T, v_0 = first median voltage\nP = [[1, 0], [0, 1]]\nF = [[1, 0.001], [0, 1]], H = [1, 0]\nQ = [[0.001, 0], [0, 0.001]], R = 0.01\nThreshold = 0.1 V')

dot.node('predict', 'Kalman Predict\nState: x = F * x\nCovariance: P = F * P * F^T + Q')

dot.node('residual', 'Compute Residual\nPredicted voltage: y_pred = H * x\nResidual: y = z_k - y_pred')

dot.attr('node', shape='diamond', style='filled', fillcolor='lightyellow')
dot.node('spike_check', 'Spike Detected?\n|y| > 0.1 V')

dot.attr('node', shape='box', style='filled', fillcolor='lightgreen')
dot.node('update', 'Kalman Update\nInnovation: S = H * P * H^T + R\nGain: K = P * H^T / S\nState: x = x + K * y\nCovariance: P = (I - K * H) * P\nOutput: Filtered voltage x[0]')

dot.node('output', 'Output Filtered Signal\nFor door-zone module control')

dot.attr('node', shape='ellipse', style='filled', fillcolor='lightblue')
dot.node('end', 'End\n(Continuous loop for next sample)')

# Define edges
dot.edge('start', 'median')
dot.edge('median', 'init_kalman')
dot.edge('init_kalman', 'predict')
dot.edge('predict', 'residual')
dot.edge('residual', 'spike_check')
dot.edge('spike_check', 'output', label='Yes\nUse predicted x[0]', style='dashed')
dot.edge('spike_check', 'update', label='No')
dot.edge('update', 'output')
dot.edge('output', 'predict', label='Next Sample', style='dotted')

# Add annotation box
dot.attr('node', shape='note', style='filled', fillcolor='lightgray')
dot.node('notes', 'Notes for Mirror Customer:\n- Median filter causal for real-time ECU\n- Tune Q, R, threshold for spike/noise\n- Use fixed-point arithmetic for efficiency\n- Validate for 10-100 ms spikes\n- Delay: ~11 ms (median) + Kalman', fontsize='10')
dot.edge('end', 'notes', style='invis')  # Position note at bottom

# Render the flowchart
dot.render('kalman_flowchart', format='png', cleanup=False)  # Saves as kalman_flowchart.png
print("Flowchart generated as kalman_flowchart.png")